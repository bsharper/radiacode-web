<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>RadiaCode Standalone Demo</title>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
<script src="https://cdn.jsdelivr.net/npm/vue-apexcharts"></script>
<script src="smoothie.js"></script>
<script src="radiacode.js"></script>
</head>
<style>
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
  background-color: #f8f9fa;
  margin: 0;
  padding: 20px;
}
#app > div {
  margin: 5px auto;
  width: 80%;
  text-align: center;
  padding: 5px;
  border: 1px #aaa dashed;
}
#app fieldset {
  display: inline-block;
  border: 0;
  padding: 0;
  margin-left: 20px;
}
.connection-controls {
  background: #f5f5f5;
  padding: 15px;
  border-radius: 8px;
  margin-bottom: 20px;
}
.connection-button {
  margin: 5px;
  padding: 10px 20px;
  font-size: 16px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  transition: background-color 0.3s;
}
.connection-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
.connect-bluetooth {
  background: #007bff;
  color: white;
}
.connect-bluetooth:hover:not(:disabled) {
  background: #0056b3;
}
.connect-usb {
  background: #28a745;
  color: white;
}
.connect-usb:hover:not(:disabled) {
  background: #1e7e34;
}
.disconnect {
  background: #dc3545;
  color: white;
}
.disconnect:hover:not(:disabled) {
  background: #c82333;
}
.status {
  margin-top: 10px;
  padding: 10px;
  border-radius: 5px;
  font-weight: bold;
}
.status.connected {
  background: #d4edda;
  color: #155724;
}
.status.disconnected {
  background: #f8d7da;
  color: #721c24;
}
.status.connecting {
  background: #fff3cd;
  color: #856404;
}
.log {
  max-height: 200px;
  overflow-y: auto;
  background: #f8f9fa;
  border: 1px solid #dee2e6;
  padding: 10px;
  margin-top: 10px;
  font-family: monospace;
  font-size: 12px;
  text-align: left;
}
.auto-update-controls {
  margin: 10px 0;
}
.device-info {
  background: #e8f4f8;
  padding: 15px;
  border-radius: 8px;
  margin-bottom: 20px;
  border: 1px solid #b8daff;
}
.device-info h3 {
  margin-top: 0;
  color: #0c5460;
}
.device-info-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 10px;
  margin-top: 10px;
}
.device-info-item {
  background: white;
  padding: 10px;
  border-radius: 5px;
  border: 1px solid #d1ecf1;
}
.device-info-item label {
  font-weight: bold;
  color: #0c5460;
  display: block;
  margin-bottom: 5px;
}
.device-info-item span {
  color: #495057;
}
.realtime-data {
  background: #f0f8e8;
  padding: 15px;
  border-radius: 8px;
  margin-bottom: 20px;
  border: 1px solid #c3e6cb;
}
.realtime-data h3 {
  margin-top: 0;
  color: #155724;
}
.realtime-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 15px;
  margin-bottom: 15px;
}
.realtime-item {
  background: white;
  padding: 15px;
  border-radius: 8px;
  border: 1px solid #c3e6cb;
  text-align: center;
}
.realtime-item .value {
  font-size: 24px;
  font-weight: bold;
  color: #155724;
  display: block;
  margin-bottom: 5px;
}
.realtime-item .error {
  font-size: 14px;
  font-weight: normal;
  color: #6c757d;
  margin-left: 5px;
}
.realtime-item .unit {
  font-size: 14px;
  color: #6c757d;
  font-weight: normal;
}
.realtime-item .label {
  font-size: 12px;
  color: #495057;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.chart-container {
  background: white;
  padding: 15px;
  border-radius: 8px;
  border: 1px solid #c3e6cb;
}
#countRateChart, #doseRateChart {
  width: 100%;
  height: 200px;
  border: 1px solid #dee2e6;
}
</style>
<body>
<div id="app">
  <!-- Connection Controls -->
  <div class="connection-controls">
    <h3>Device Connection</h3>
    <button 
      class="connection-button connect-bluetooth" 
      @click="connectBluetooth" 
      :disabled="isConnected || isConnecting">
      üì± Connect Bluetooth
    </button>
    <button 
      class="connection-button connect-usb" 
      @click="connectUSB" 
      :disabled="isConnected || isConnecting">
      üîå Connect USB
    </button>
    <button 
      class="connection-button disconnect" 
      @click="disconnect" 
      :disabled="!isConnected">
      ‚ùå Disconnect
    </button>
    
    <div :class="['status', connectionStatus.toLowerCase()]">
      {{ connectionStatusText }}
    </div>
    
    <div class="auto-update-controls" v-if="isConnected">
      <button @click="toggleAutoUpdate" class="connection-button">
        Auto-update: {{ autoUpdateEnabled ? "ON" : "OFF" }}
      </button>
      <span v-if="autoUpdateEnabled">({{ updateInterval/1000 }}s interval)</span>
    </div>
    
    <div class="log" v-if="logMessages.length > 0">
      <div v-for="msg in logMessages" :key="msg.id">
        <span style="color: #666;">{{ msg.timestamp }}</span> {{ msg.message }}
      </div>
    </div>
  </div>

  <!-- Device Information -->
  <div class="device-info" v-if="isConnected">
    <h3>üìä Device Information</h3>
    <div class="device-info-grid">
      <div class="device-info-item">
        <label>Serial Number:</label>
        <span>{{ deviceInfo.serialNumber || 'Loading...' }}</span>
      </div>
      <div class="device-info-item">
        <label>Firmware Version:</label>
        <span>{{ deviceInfo.firmwareVersion || 'Loading...' }}</span>
      </div>
      <div class="device-info-item">
        <label>Connection Type:</label>
        <span>{{ deviceInfo.connectionType || 'Unknown' }}</span>
      </div>
      <div class="device-info-item">
        <label>Last Update:</label>
        <span>{{ deviceInfo.lastUpdate || 'Never' }}</span>
      </div>
    </div>
  </div>

  <!-- Real-time Data -->
  <div class="realtime-data" v-if="isConnected">
    <h3>‚ö° Real-time Data</h3>
    <div class="realtime-grid">
      <div class="realtime-item">
        <div class="label">Count Rate</div>
        <span class="value">
          {{ currentData.countRate.toFixed(2) }}
          <span class="error">¬± {{ currentData.countRateError.toFixed(2) }}</span>
        </span>
        <span class="unit">CPS</span>
      </div>
      <div class="realtime-item">
        <div class="label">Dose Rate</div>
        <span class="value">
          {{ currentData.doseRate.toFixed(4) }}
          <span class="error">¬± {{ currentData.doseRateError.toFixed(4) }}</span>
        </span>
        <span class="unit">¬µSv/h</span>
      </div>
    </div>
    <div class="realtime-grid">
      <div class="chart-container">
        <h4 style="margin-top: 0; color: #155724;">Count Rate (CPS)</h4>
        <canvas id="countRateChart"></canvas>
      </div>
      <div class="chart-container">
        <h4 style="margin-top: 0; color: #155724;">Dose Rate (¬µSv/h)</h4>
        <canvas id="doseRateChart"></canvas>
      </div>
    </div>
  </div>

  <!-- Spectrum Chart -->
  <div>
    <apexchart type="bar" height="350" :options="spectrumChartOptions" :series="spectrum_series"></apexchart>
    <div>
      <fieldset>
        <input type="checkbox" id="spectrum_x_accum" v-model="spectrum_accum">
        <label for="spectrum_x_accum">Accumulated</label>
      </fieldset>
      <fieldset>
        <input type="radio" id="spectrum_x_channel" v-bind:value="false" v-model="spectrum_energy">
        <label for="spectrum_x_channel">Channel</label>

        <input type="radio" id="spectrum_x_energy" v-bind:value="true" v-model="spectrum_energy">
        <label for="spectrum_x_energy">Energy</label>
      </fieldset>
      <fieldset>
        <input type="radio" id="spectrum_linear" v-bind:value="false" v-model="spectrum_logarithmic">
        <label for="spectrum_linear">Linear</label>
        <input type="radio" id="spectrum_log" v-bind:value="true" v-model="spectrum_logarithmic">
        <label for="spectrum_log">Logarithmic</label>
      </fieldset>
    </div>
    <button @click="updateSpectrum" :disabled="!isConnected">Update spectrum</button>
    <button @click="resetSpectrum" :disabled="!isConnected">Reset spectrum</button>
  </div>

  <!-- Rates Chart -->
  <div>
    <apexchart type="line" height="350" :options="ratesChartOptions" :series="rates_series"></apexchart>
    <div>
      <button @click="clearRatesData">Clear Rates Data</button>
      <span v-if="rates_series.length > 0">
        Data points: {{ rates_series[0]?.data?.length || 0 }}
      </span>
    </div>
  </div>
</div>

<script>
const common_options = {
  chart: {
    animations: {enabled: false},
    zoom: {autoScaleYaxis: true},
  },
  tooltip: {intersect: false},
  grid: {xaxis: {lines: {show: true}}},
  dataLabels: {enabled: false},
};

var app = new Vue({
  el: '#app',
  components: {
    apexchart: VueApexCharts,
  },
  data: function() {
    return {
      device: null,
      isConnected: false,
      isConnecting: false,
      connectionStatus: 'Disconnected',
      connectionStatusText: 'Not connected to device',
      
      // Device information
      deviceInfo: {
        firmwareVersion: null,
        serialNumber: null,
        connectionType: null,
        lastUpdate: null
      },
      
      // Real-time data
      currentData: {
        countRate: 0,
        doseRate: 0,
        countRateError: 0,
        doseRateError: 0
      },
      
      // Smoothie chart
      countRateChart: null,
      doseRateChart: null,
      countRateTimeSeries: null,
      doseRateTimeSeries: null,
      
      // Auto-update functionality
      autoUpdateEnabled: false,
      updateInterval: 2000, // 2 seconds
      updateTimer: null,
      
      // Logging
      logMessages: [],
      logCounter: 0,
      
      // Spectrum data
      spectrum_duration: 0,
      spectrum_series: [],
      spectrum_coef: [0, 0, 0],
      spectrum_accum: false,
      spectrum_logarithmic: true,
      spectrum_energy: true,
      
      // Rates data
      rates_series: [
        {name: 'Count Rate', data: [], yAxisIndex: 0},
        {name: 'Dose Rate', data: [], yAxisIndex: 1}
      ],
      
      ratesChartOptions: {
        ...common_options,
        title: {text: 'CountRate & DoseRate'},
        xaxis: {type: 'datetime'},
        yaxis: [
          {seriesName: 'countrate', title: {text: 'CPS'}, labels: {formatter:(v) => v.toFixed(2) + ' CPS'}},
          {seriesName: 'doserate',  title: {text: 'ŒºSv/h'}, labels: {formatter:(v) => v.toFixed(6) + ' ŒºSv/h'}, opposite: true},
        ],
      },
    };
  },
  watch: {
    spectrum_accum() {
      if (this.isConnected) {
        this.updateSpectrum();
      }
    }
  },
  computed: {
    spectrumChartOptions() {
      const a0 = this.spectrum_coef[0], a1 = this.spectrum_coef[1], a2 = this.spectrum_coef[2];
      const fmt = this.spectrum_energy ? ((c) => (a0 + a1*c + a2*c*c).toFixed(0)) : undefined;
      const title = this.spectrum_energy ? 'keV' : 'channel';
      return{
        ...common_options,
        title: {text: `Spectrum, ${this.spectrum_duration} seconds`},
        xaxis: {type: 'numeric', title: {text: title}, tickAmount: 25, labels: {formatter:fmt}},
        yaxis: {logarithmic: this.spectrum_logarithmic, decimalsInFloat: 0},
        plotOptions: {bar: {columnWidth: '95%'}},
      };
    },
  },
  created() {
    this.log('RadiaCode Standalone Demo initialized');
    this.log('Connect to your device using Bluetooth or USB');
  },
  beforeDestroy: function() {
    if (this.updateTimer) {
      clearInterval(this.updateTimer);
    }
    if (this.device && this.isConnected) {
      this.device.disconnect();
    }
  },
  methods: {
    log(message) {
      const timestamp = new Date().toLocaleTimeString();
      this.logMessages.push({
        id: this.logCounter++,
        timestamp,
        message
      });
      
      // Keep only last 50 messages
      if (this.logMessages.length > 50) {
        this.logMessages = this.logMessages.slice(-50);
      }
      
      // Auto-scroll to bottom
      this.$nextTick(() => {
        const logEl = document.querySelector('.log');
        if (logEl) {
          logEl.scrollTop = logEl.scrollHeight;
        }
      });
    },

    async connectBluetooth() {
      try {
        this.isConnecting = true;
        this.connectionStatus = 'Connecting';
        this.connectionStatusText = 'Connecting via Bluetooth...';
        this.log('Attempting Bluetooth connection...');
        
        this.device = new RadiaCode(null, true); // Request Bluetooth
        await this.device.connect();
        
        this.isConnected = true;
        this.connectionStatus = 'Connected';
        this.connectionStatusText = 'Connected via Bluetooth';
        this.deviceInfo.connectionType = 'Bluetooth';
        this.log('‚úÖ Connected successfully via Bluetooth');
        window.device = this.device; // For debugging
        await this.initializeDevice();
        
      } catch (error) {
        this.log(`‚ùå Bluetooth connection failed: ${error.message}`);
        this.connectionStatus = 'Disconnected';
        this.connectionStatusText = `Connection failed: ${error.message}`;
        this.device = null;
      } finally {
        this.isConnecting = false;
      }
    },

    async connectUSB() {
      try {
        this.isConnecting = true;
        this.connectionStatus = 'Connecting';
        this.connectionStatusText = 'Connecting via USB...';
        this.log('Attempting USB connection...');
        
        if (!RadiaCodeUSBTransport.isSupported()) {
          throw new Error('Web USB is not supported in this browser');
        }
        
        this.device = new RadiaCode(); // Default to USB
        await this.device.connect();
        
        this.isConnected = true;
        this.connectionStatus = 'Connected';
        this.connectionStatusText = 'Connected via USB';
        this.deviceInfo.connectionType = 'USB';
        this.log('‚úÖ Connected successfully via USB');
        
        await this.initializeDevice();
        
      } catch (error) {
        this.log(`‚ùå USB connection failed: ${error.message}`);
        this.connectionStatus = 'Disconnected';
        this.connectionStatusText = `Connection failed: ${error.message}`;
        this.device = null;
      } finally {
        this.isConnecting = false;
      }
    },

    async initializeDevice() {
      try {
        // Get device info sequentially to avoid GATT conflicts
        this.log('Getting firmware version...');
        const version = await this.device.getFirmwareVersion();
        this.deviceInfo.firmwareVersion = `v${version.target.major}.${version.target.minor}`;
        this.log(`Firmware: ${this.deviceInfo.firmwareVersion}`);
        
        this.log('Getting serial number...');
        const serial = await this.device.getSerialNumber();
        this.deviceInfo.serialNumber = serial;
        this.log(`Device: ${serial}`);
        
        // Test data buffer to see what we get
        this.log('Testing initial data buffer...');
        const testData = await this.device.data_buf();
        this.log(`Got ${testData.length} records from data buffer`);
        
        for (let i = 0; i < Math.min(3, testData.length); i++) {
          const record = testData[i];
          if (record instanceof RealTimeData) {
            this.log(`Sample data[${i}]: CR=${record.count_rate}, DR=${record.dose_rate}, CR_err=${record.count_rate_err}, DR_err=${record.dose_rate_err}`);
          } else {
            this.log(`Sample data[${i}]: ${record.constructor.name}`);
          }
        }
        
        // Get initial spectrum
        this.log('Getting initial spectrum...');
        await this.updateSpectrum();
        
        // Start auto-update by default
        this.toggleAutoUpdate();
        
        // Initialize smoothie chart
        this.initializeSmoothieChart();
        
        this.log('‚úÖ Device initialization completed successfully');
        
      } catch (error) {
        this.log(`‚ùå Device initialization failed: ${error.message}`);
        // Don't throw the error - connection is still working
      }
    },

    initializeSmoothieChart() {
      // Create time series for count rate and dose rate
      this.countRateTimeSeries = new TimeSeries();
      this.doseRateTimeSeries = new TimeSeries();
      
      // Create the count rate chart
      this.countRateChart = new SmoothieChart({
        responsive: true,
        millisPerPixel: 10,
        maxValueScale: 1.1,
        minValueScale: 1.1,
        tooltip: true,
        grid: {
          strokeStyle: 'rgba(119, 119, 119, 0.2)',
          fillStyle: 'rgba(0, 0, 0, 0.02)',
          lineWidth: 1,
          millisPerLine: 5000,
          verticalSections: 6
        },
        labels: {
          fillStyle: 'rgba(0, 0, 0, 0.6)',
          fontSize: 12
        }
      });
      
      // Create the dose rate chart
      this.doseRateChart = new SmoothieChart({
        responsive: true,
        millisPerPixel: 10,
        maxValueScale: 1.1,
        minValueScale: 1.1,
        tooltip: true,
        grid: {
          strokeStyle: 'rgba(119, 119, 119, 0.2)',
          fillStyle: 'rgba(0, 0, 0, 0.02)',
          lineWidth: 1,
          millisPerLine: 5000,
          verticalSections: 6
        },
        labels: {
          fillStyle: 'rgba(0, 0, 0, 0.6)',
          fontSize: 12
        }
      });
      
      // Add time series to charts
      this.countRateChart.addTimeSeries(this.countRateTimeSeries, {
        strokeStyle: 'rgba(0, 123, 255, 1)',
        fillStyle: 'rgba(0, 123, 255, 0.1)',
        lineWidth: 2
      });
      
      this.doseRateChart.addTimeSeries(this.doseRateTimeSeries, {
        strokeStyle: 'rgba(40, 167, 69, 1)',
        fillStyle: 'rgba(40, 167, 69, 0.1)',
        lineWidth: 2
      });
      
      // Start streaming to canvases
      this.$nextTick(() => {
        const countCanvas = document.getElementById('countRateChart');
        const doseCanvas = document.getElementById('doseRateChart');
        
        if (countCanvas && doseCanvas) {
          this.countRateChart.streamTo(countCanvas, 2000);
          this.doseRateChart.streamTo(doseCanvas, 2000);
          this.log('‚úÖ Real-time charts initialized');
        }
      });
    },

    destroySmoothieChart() {
      if (this.countRateChart) {
        this.countRateChart.stop();
        this.countRateChart = null;
      }
      if (this.doseRateChart) {
        this.doseRateChart.stop();
        this.doseRateChart = null;
      }
      this.countRateTimeSeries = null;
      this.doseRateTimeSeries = null;
    },

    async disconnect() {
      try {
        if (this.updateTimer) {
          clearInterval(this.updateTimer);
          this.updateTimer = null;
          this.autoUpdateEnabled = false;
        }
        
        if (this.device) {
          await this.device.disconnect();
          this.log('‚úÖ Disconnected successfully');
        }
        
        // Destroy smoothie chart
        this.destroySmoothieChart();
        
        this.device = null;
        this.isConnected = false;
        this.connectionStatus = 'Disconnected';
        this.connectionStatusText = 'Not connected to device';
        
        // Clear device information
        this.deviceInfo = {
          firmwareVersion: null,
          serialNumber: null,
          connectionType: null,
          lastUpdate: null
        };
        
        // Reset current data
        this.currentData = {
          countRate: 0,
          doseRate: 0,
          countRateError: 0,
          doseRateError: 0
        };
        
      } catch (error) {
        this.log(`‚ùå Disconnect failed: ${error.message}`);
      }
    },

    toggleAutoUpdate() {
      if (this.autoUpdateEnabled) {
        // Stop auto-update
        if (this.updateTimer) {
          clearInterval(this.updateTimer);
          this.updateTimer = null;
        }
        this.autoUpdateEnabled = false;
        this.log('Auto-update stopped');
      } else {
        // Start auto-update
        this.autoUpdateEnabled = true;
        this.updateTimer = setInterval(() => {
          this.updateRatesData();
        }, this.updateInterval);
        this.log(`Auto-update started (${this.updateInterval/1000}s interval)`);
      }
    },

    async updateRatesData() {
      if (!this.isConnected || !this.device) return;
      
      try {
        const data = await this.device.data_buf();
        const now = new Date().getTime();
        
        // Process real-time data
        for (const record of data) {
          if (record instanceof RealTimeData) {
            // Debug logging - more detailed
            this.log(`RealTimeData: CR=${record.count_rate.toFixed(2)} CPS, DR=${record.dose_rate.toFixed(6)} ¬µSv/h, flags=0x${record.flags.toString(16)}`);
            
            // Update current data
            this.currentData.countRate = record.count_rate;
            this.currentData.doseRate = record.dose_rate;
            this.currentData.countRateError = record.count_rate_err;
            this.currentData.doseRateError = record.dose_rate_err;
            
            // Add to smoothie chart
            if (this.countRateTimeSeries && this.doseRateTimeSeries) {
              this.countRateTimeSeries.append(now, record.count_rate);
              // Use original dose rate value (¬µSv/h) for dose rate chart
              this.doseRateTimeSeries.append(now, record.dose_rate);
            }
            
            // Add to rates series
            this.rates_series[0].data.push([now, record.count_rate]);
            this.rates_series[1].data.push([now, record.dose_rate]);
            
            // Update last update time
            this.deviceInfo.lastUpdate = new Date().toLocaleTimeString();
            
            // Keep only last 100 data points
            if (this.rates_series[0].data.length > 100) {
              this.rates_series[0].data = this.rates_series[0].data.slice(-100);
              this.rates_series[1].data = this.rates_series[1].data.slice(-100);
            }
            
            // Trigger chart update
            this.rates_series = [...this.rates_series];
            break; // Only process the first real-time record
          }
        }
        
      } catch (error) {
        this.log(`‚ùå Failed to update rates data: ${error.message}`);
      }
    },

    async updateSpectrum() {
      if (!this.isConnected || !this.device) return;
      
      try {
        this.log('Updating spectrum...');
        
        const spectrum = this.spectrum_accum ? 
          await this.device.spectrum_accum() : 
          await this.device.spectrum();
        
        this.spectrum_duration = spectrum.duration;
        this.spectrum_coef = [spectrum.a0, spectrum.a1, spectrum.a2];
        
        // Convert spectrum data to chart format
        const counts = spectrum.counts;
        const data = [];
        
        if (this.spectrum_energy) {
          // Energy scale
          for (let i = 0; i < counts.length; i++) {
            const energy = spectrum.channelToEnergy(i + 0.5);
            data.push([energy, counts[i]]);
          }
        } else {
          // Channel scale
          for (let i = 0; i < counts.length; i++) {
            data.push([i, counts[i]]);
          }
        }
        
        this.spectrum_series = [{
          name: 'Counts',
          data: data
        }];
        
        this.log(`‚úÖ Spectrum updated: ${spectrum.duration}s, ${spectrum.getTotalCounts()} total counts`);
        
      } catch (error) {
        this.log(`‚ùå Failed to update spectrum: ${error.message}`);
      }
    },

    async resetSpectrum() {
      if (!this.isConnected || !this.device) return;
      
      try {
        this.log('Resetting spectrum...');
        await this.device.spectrum_reset();
        this.log('‚úÖ Spectrum reset successfully');
        
        // Wait a moment then update
        setTimeout(() => {
          this.updateSpectrum();
        }, 1000);
        
      } catch (error) {
        this.log(`‚ùå Failed to reset spectrum: ${error.message}`);
      }
    },

    clearRatesData() {
      this.rates_series[0].data = [];
      this.rates_series[1].data = [];
      this.rates_series = [...this.rates_series];
      this.log('Rates data cleared');
    }
  },
});
</script>
</body>
</html>
