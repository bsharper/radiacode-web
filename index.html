<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>RadiaCode Standalone Demo</title>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
<script src="https://cdn.jsdelivr.net/npm/vue-apexcharts"></script>
<script src="smoothie.js"></script>
<script src="radiacode.js"></script>
</head>
<link rel="stylesheet" href="css/fontello.css">
<link rel="stylesheet" href="css/animation.css">
<link rel="stylesheet" href="css/main.css">
<body>
<div id="app">
  <!-- Connection Controls -->
  <div class="connection-controls">
    <h3>Device Connection</h3>
    <div class="connection-row">
      <div class="connection-buttons">
        <button 
          class="connection-button connect-bluetooth" 
          @click="connectBluetooth" 
          :disabled="isConnected || isConnecting">
          <i class="icon-bluetooth-b"></i>Connect Bluetooth
        </button>
        <button 
          class="connection-button connect-usb" 
          @click="connectUSB" 
          :disabled="isConnected || isConnecting">
          <i class="icon-usb"></i> Connect USB
        </button>
        <button 
          class="connection-button disconnect" 
          @click="disconnect" 
          :disabled="!isConnected">
          🔌 Disconnect
        </button>
      </div>
      
      <div :class="['status', connectionStatus.toLowerCase()]">
        {{ connectionStatusText }}
      </div>
    </div>
    
    <div class="auto-update-controls" v-if="isConnected">
      <button @click="toggleAutoUpdate" class="connection-button">
        Auto-update: {{ autoUpdateEnabled ? "ON" : "OFF" }}
      </button>
      <span v-if="autoUpdateEnabled">({{ updateInterval/1000 }}s interval)</span>
    </div>
    
    <div class="log-section" v-if="logMessages.length > 0">
      <div class="log-header" @click="toggleLogExpanded">
        <div class="log-header-left">
          <span class="log-toggle-icon">{{ logExpanded ? '▼' : '▶' }}</span>
          <span>Activity Log ({{ logMessages.length }} messages)</span>
          <span v-if="logExpanded && !logAutoScroll" class="auto-scroll-indicator">Scroll paused</span>
        </div>
        <button @click.stop="clearLog" class="clear-log-button">Clear</button>
      </div>
      <div class="log" v-show="logExpanded" ref="logContainer" @scroll="handleLogScroll">
        <div v-for="msg in visibleLogMessages" :key="msg.id" class="log-entry">
          <span class="log-timestamp">{{ msg.timestamp }}</span> 
          <span class="log-message">{{ msg.message }}</span>
        </div>
        <div v-if="logMessages.length > maxVisibleMessages" class="log-entry log-info">
          ... {{ logMessages.length - maxVisibleMessages }} earlier messages (scroll to top to load)
        </div>
      </div>
    </div>
  </div>

  <!-- Device Information -->
  <div class="device-info" v-if="isConnected">
    <h3>Device Information</h3>
    <div class="device-info-grid">
      <div class="device-info-item">
        <label>Serial Number:</label>
        <span>{{ deviceInfo.serialNumber || 'Loading...' }}</span>
      </div>
      <div class="device-info-item">
        <label>Firmware Version:</label>
        <span>{{ deviceInfo.firmwareVersion || 'Loading...' }}</span>
      </div>
      <div class="device-info-item">
        <label>Connection Type:</label>
        <span>{{ deviceInfo.connectionType || 'Unknown' }}</span>
      </div>
      <div class="device-info-item">
        <label>Last Update:</label>
        <span>{{ deviceInfo.lastUpdate || 'Never' }}</span>
      </div>
    </div>
  </div>

  <!-- Real-time Data -->
  <div class="realtime-data" v-if="isConnected">
    <h3>Real-time Data</h3>
    <div class="realtime-grid">
      <div class="realtime-item">
        <div class="label">Count Rate</div>
        <span class="value">
          {{ currentData.countRate.toFixed(2) }}
          <span class="error">± {{ currentData.countRateError.toFixed(2) }}</span>
        </span>
        <span class="unit">CPS</span>
      </div>
      <div class="realtime-item">
        <div class="label">Dose Rate</div>
        <span class="value">
          {{ currentData.doseRate.toFixed(4) }}
          <span class="error">± {{ currentData.doseRateError.toFixed(4) }}</span>
        </span>
        <span class="unit">µSv/h</span>
      </div>
    </div>
    <div class="realtime-grid">
      <div class="chart-container">
        <h4 style="margin-top: 0; color: #155724;">Count Rate (CPS)</h4>
        <canvas id="countRateChart"></canvas>
      </div>
      <div class="chart-container">
        <h4 style="margin-top: 0; color: #155724;">Dose Rate (µSv/h)</h4>
        <canvas id="doseRateChart"></canvas>
      </div>
    </div>
  </div>

  <!-- Spectrum Chart -->
  <div>
    <apexchart type="bar" height="350" :options="spectrumChartOptions" :series="spectrum_series"></apexchart>
    <div>
      <fieldset>
        <input type="checkbox" id="spectrum_x_accum" v-model="spectrum_accum">
        <label for="spectrum_x_accum">Accumulated</label>
      </fieldset>
      <fieldset>
        <input type="radio" id="spectrum_x_channel" v-bind:value="false" v-model="spectrum_energy">
        <label for="spectrum_x_channel">Channel</label>

        <input type="radio" id="spectrum_x_energy" v-bind:value="true" v-model="spectrum_energy">
        <label for="spectrum_x_energy">Energy</label>
      </fieldset>
      <fieldset>
        <input type="radio" id="spectrum_linear" v-bind:value="false" v-model="spectrum_logarithmic">
        <label for="spectrum_linear">Linear</label>
        <input type="radio" id="spectrum_log" v-bind:value="true" v-model="spectrum_logarithmic">
        <label for="spectrum_log">Logarithmic</label>
      </fieldset>
    </div>
    <button @click="updateSpectrum" :disabled="!isConnected">Update spectrum</button>
    <button @click="resetSpectrum" :disabled="!isConnected">Reset spectrum</button>
  </div>

  <!-- Rates Chart -->
  <div>
    <apexchart type="line" height="350" :options="ratesChartOptions" :series="rates_series"></apexchart>
    <div>
      <button @click="clearRatesData">Clear Rates Data</button>
      <span v-if="rates_series.length > 0">
        Data points: {{ rates_series[0]?.data?.length || 0 }}
      </span>
    </div>
  </div>
</div>

<script>
const common_options = {
  chart: {
    animations: {enabled: false},
    zoom: {autoScaleYaxis: true},
  },
  tooltip: {intersect: false},
  grid: {xaxis: {lines: {show: true}}},
  dataLabels: {enabled: false},
};

var app = new Vue({
  el: '#app',
  components: {
    apexchart: VueApexCharts,
  },
  data: function() {
    return {
      device: null,
      isConnected: false,
      isConnecting: false,
      connectionStatus: 'Disconnected',
      connectionStatusText: 'Not connected to device',
      
      // Device information
      deviceInfo: {
        firmwareVersion: null,
        serialNumber: null,
        connectionType: null,
        lastUpdate: null
      },
      
      // Real-time data
      currentData: {
        countRate: 0,
        doseRate: 0,
        countRateError: 0,
        doseRateError: 0
      },
      
      // Smoothie chart
      countRateChart: null,
      doseRateChart: null,
      countRateTimeSeries: null,
      doseRateTimeSeries: null,
      
      // Auto-update functionality
      autoUpdateEnabled: false,
      updateInterval: 1000, // 1 second
      updateTimer: null,
      
      // Logging
      logMessages: [],
      logCounter: 0,
      logExpanded: true, // Start expanded by default
      maxVisibleMessages: 500, // Limit DOM elements for performance
      logAutoScroll: true, // Whether to auto-scroll to bottom on new messages
      
      // Spectrum data
      spectrum_duration: 0,
      spectrum_series: [],
      spectrum_coef: [0, 0, 0],
      spectrum_accum: false,
      spectrum_logarithmic: true,
      spectrum_energy: true,
      
      // Rates data
      rates_series: [
        {name: 'Count Rate', data: [], yAxisIndex: 0},
        {name: 'Dose Rate', data: [], yAxisIndex: 1}
      ],
      
      ratesChartOptions: {
        ...common_options,
        title: {text: 'CountRate & DoseRate'},
        xaxis: {type: 'datetime'},
        yaxis: [
          {seriesName: 'countrate', title: {text: 'CPS'}, labels: {formatter:(v) => v.toFixed(2) + ' CPS'}},
          {seriesName: 'doserate',  title: {text: 'μSv/h'}, labels: {formatter:(v) => v.toFixed(6) + ' μSv/h'}, opposite: true},
        ],
      },
    };
  },
  watch: {
    spectrum_accum() {
      if (this.isConnected) {
        this.updateSpectrum();
      }
    }
  },
  computed: {
    visibleLogMessages() {
      // Show the most recent messages for performance
      if (this.logMessages.length <= this.maxVisibleMessages) {
        return this.logMessages;
      }
      return this.logMessages.slice(-this.maxVisibleMessages);
    },
    spectrumChartOptions() {
      const a0 = this.spectrum_coef[0], a1 = this.spectrum_coef[1], a2 = this.spectrum_coef[2];
      const fmt = this.spectrum_energy ? ((c) => (a0 + a1*c + a2*c*c).toFixed(0)) : undefined;
      const title = this.spectrum_energy ? 'keV' : 'channel';
      return{
        ...common_options,
        title: {text: `Spectrum, ${this.spectrum_duration} seconds`},
        xaxis: {type: 'numeric', title: {text: title}, tickAmount: 25, labels: {formatter:fmt}},
        yaxis: {logarithmic: this.spectrum_logarithmic, decimalsInFloat: 0},
        plotOptions: {bar: {columnWidth: '95%'}},
      };
    },
  },
  created() {
    this.log('RadiaCode Standalone Demo initialized');
    this.log('Connect to your device using Bluetooth or USB');
  },
  beforeDestroy: function() {
    if (this.updateTimer) {
      clearInterval(this.updateTimer);
    }
    if (this.device && this.isConnected) {
      this.device.disconnect();
    }
  },
  methods: {
    log(message) {
      const timestamp = new Date().toLocaleTimeString();
      this.logMessages.push({
        id: this.logCounter++,
        timestamp,
        message
      });
      
      // Auto-scroll to bottom only if user is already at the bottom and log is expanded
      this.$nextTick(() => {
        if (this.logExpanded && this.logAutoScroll) {
          const logEl = document.querySelector('.log');
          if (logEl) {
            logEl.scrollTop = logEl.scrollHeight;
          }
        }
      });
    },

    handleLogScroll() {
      const logEl = this.$refs.logContainer;
      if (logEl) {
        // Check if user is at the bottom (within 5px tolerance)
        const isAtBottom = logEl.scrollHeight - logEl.scrollTop - logEl.clientHeight < 5;
        this.logAutoScroll = isAtBottom;
      }
    },

    toggleLogExpanded() {
      this.logExpanded = !this.logExpanded;
      
      // Auto-scroll to bottom when expanding (and reset auto-scroll to true)
      if (this.logExpanded) {
        this.logAutoScroll = true;
        this.$nextTick(() => {
          const logEl = document.querySelector('.log');
          if (logEl) {
            logEl.scrollTop = logEl.scrollHeight;
          }
        });
      }
    },

    clearLog() {
      this.logMessages = [];
      this.logCounter = 0;
      this.logAutoScroll = true; // Reset auto-scroll when clearing
      this.log('Log cleared');
    },

    async connectBluetooth() {
      try {
        this.isConnecting = true;
        this.connectionStatus = 'Connecting';
        this.connectionStatusText = 'Connecting via Bluetooth...';
        this.log('Attempting Bluetooth connection...');
        
        this.device = new RadiaCode(null, true); // Request Bluetooth
        await this.device.connect();
        
        this.isConnected = true;
        this.connectionStatus = 'Connected';
        this.connectionStatusText = 'Connected via Bluetooth';
        this.deviceInfo.connectionType = 'Bluetooth';
        this.log('✅ Connected successfully via Bluetooth');
        window.device = this.device; // For debugging
        await this.initializeDevice();
        
      } catch (error) {
        this.log(`❌ Bluetooth connection failed: ${error.message}`);
        this.connectionStatus = 'Disconnected';
        this.connectionStatusText = `Connection failed: ${error.message}`;
        this.device = null;
      } finally {
        this.isConnecting = false;
      }
    },

    async connectUSB() {
      try {
        this.isConnecting = true;
        this.connectionStatus = 'Connecting';
        this.connectionStatusText = 'Connecting via USB...';
        this.log('Attempting USB connection...');
        
        if (!RadiaCodeUSBTransport.isSupported()) {
          throw new Error('Web USB is not supported in this browser');
        }
        
        this.device = new RadiaCode(); // Default to USB
        await this.device.connect();
        
        this.isConnected = true;
        this.connectionStatus = 'Connected';
        this.connectionStatusText = 'Connected via USB';
        this.deviceInfo.connectionType = 'USB';
        this.log('✅ Connected successfully via USB');
        
        await this.initializeDevice();
        
      } catch (error) {
        this.log(`❌ USB connection failed: ${error.message}`);
        this.connectionStatus = 'Disconnected';
        this.connectionStatusText = `Connection failed: ${error.message}`;
        this.device = null;
      } finally {
        this.isConnecting = false;
      }
    },

    async initializeDevice() {
      try {
        // Get device info sequentially to avoid GATT conflicts
        this.log('Getting firmware version...');
        const version = await this.device.getFirmwareVersion();
        this.deviceInfo.firmwareVersion = `v${version.target.major}.${version.target.minor}`;
        this.log(`Firmware: ${this.deviceInfo.firmwareVersion}`);
        
        this.log('Getting serial number...');
        const serial = await this.device.getSerialNumber();
        this.deviceInfo.serialNumber = serial;
        this.log(`Device: ${serial}`);
        
        // Test data buffer to see what we get
        this.log('Testing initial data buffer...');
        const testData = await this.device.data_buf();
        this.log(`Got ${testData.length} records from data buffer`);
        
        for (let i = 0; i < Math.min(3, testData.length); i++) {
          const record = testData[i];
          if (record instanceof RealTimeData) {
            this.log(`Sample data[${i}]: CR=${record.count_rate}, DR=${record.dose_rate}, CR_err=${record.count_rate_err}, DR_err=${record.dose_rate_err}`);
          } else {
            this.log(`Sample data[${i}]: ${record.constructor.name}`);
          }
        }
        
        // Get initial spectrum
        this.log('Getting initial spectrum...');
        await this.updateSpectrum();
        
        // Start auto-update by default
        this.toggleAutoUpdate();
        
        // Initialize smoothie chart
        this.initializeSmoothieChart();
        
        this.log('✅ Device initialization completed successfully');
        
      } catch (error) {
        this.log(`❌ Device initialization failed: ${error.message}`);
        // Don't throw the error - connection is still working
      }
    },

    initializeSmoothieChart() {
      // Create time series for count rate and dose rate
      this.countRateTimeSeries = new TimeSeries();
      this.doseRateTimeSeries = new TimeSeries();
      
      // Create the count rate chart
      this.countRateChart = new SmoothieChart({
        responsive: true,
        millisPerPixel: 10,
        maxValueScale: 1.1,
        minValueScale: 1.1,
        tooltip: true,
        grid: {
          strokeStyle: 'rgba(119, 119, 119, 0.2)',
          fillStyle: 'rgba(0, 0, 0, 0.02)',
          lineWidth: 1,
          millisPerLine: 5000,
          verticalSections: 6
        },
        labels: {
          fillStyle: 'rgba(0, 0, 0, 0.6)',
          fontSize: 12
        }
      });
      
      // Create the dose rate chart
      this.doseRateChart = new SmoothieChart({
        responsive: true,
        millisPerPixel: 10,
        maxValueScale: 1.1,
        minValueScale: 1.1,
        tooltip: true,
        grid: {
          strokeStyle: 'rgba(119, 119, 119, 0.2)',
          fillStyle: 'rgba(0, 0, 0, 0.02)',
          lineWidth: 1,
          millisPerLine: 5000,
          verticalSections: 6
        },
        labels: {
          fillStyle: 'rgba(0, 0, 0, 0.6)',
          fontSize: 12
        }
      });
      
      // Add time series to charts
      this.countRateChart.addTimeSeries(this.countRateTimeSeries, {
        strokeStyle: 'rgba(0, 123, 255, 1)',
        fillStyle: 'rgba(0, 123, 255, 0.1)',
        lineWidth: 2
      });
      
      this.doseRateChart.addTimeSeries(this.doseRateTimeSeries, {
        strokeStyle: 'rgba(40, 167, 69, 1)',
        fillStyle: 'rgba(40, 167, 69, 0.1)',
        lineWidth: 2
      });
      
      // Start streaming to canvases
      this.$nextTick(() => {
        const countCanvas = document.getElementById('countRateChart');
        const doseCanvas = document.getElementById('doseRateChart');
        
        if (countCanvas && doseCanvas) {
          this.countRateChart.streamTo(countCanvas, 1500);
          this.doseRateChart.streamTo(doseCanvas, 1500);
          this.log('✅ Real-time charts initialized');
        }
      });
    },

    destroySmoothieChart() {
      if (this.countRateChart) {
        this.countRateChart.stop();
        this.countRateChart = null;
      }
      if (this.doseRateChart) {
        this.doseRateChart.stop();
        this.doseRateChart = null;
      }
      this.countRateTimeSeries = null;
      this.doseRateTimeSeries = null;
    },

    async disconnect() {
      try {
        if (this.updateTimer) {
          clearInterval(this.updateTimer);
          this.updateTimer = null;
          this.autoUpdateEnabled = false;
        }
        
        if (this.device) {
          await this.device.disconnect();
          this.log('✅ Disconnected successfully');
        }
        
        // Destroy smoothie chart
        this.destroySmoothieChart();
        
        this.device = null;
        this.isConnected = false;
        this.connectionStatus = 'Disconnected';
        this.connectionStatusText = 'Not connected to device';
        
        // Clear device information
        this.deviceInfo = {
          firmwareVersion: null,
          serialNumber: null,
          connectionType: null,
          lastUpdate: null
        };
        
        // Reset current data
        this.currentData = {
          countRate: 0,
          doseRate: 0,
          countRateError: 0,
          doseRateError: 0
        };
        
      } catch (error) {
        this.log(`❌ Disconnect failed: ${error.message}`);
      }
    },

    toggleAutoUpdate() {
      if (this.autoUpdateEnabled) {
        // Stop auto-update
        if (this.updateTimer) {
          clearInterval(this.updateTimer);
          this.updateTimer = null;
        }
        this.autoUpdateEnabled = false;
        this.log('Auto-update stopped');
      } else {
        // Start auto-update
        this.autoUpdateEnabled = true;
        this.updateTimer = setInterval(() => {
          this.updateRatesData();
        }, this.updateInterval);
        this.log(`Auto-update started (${this.updateInterval/1000}s interval)`);
      }
    },

    async updateRatesData() {
      if (!this.isConnected || !this.device) return;
      
      try {
        const data = await this.device.data_buf();
        const now = new Date().getTime();
        
        // Process real-time data
        for (const record of data) {
          if (record instanceof RealTimeData) {
            // Debug logging - more detailed
            this.log(`RealTimeData: CR=${record.count_rate.toFixed(2)} CPS, DR=${record.dose_rate.toFixed(6)} µSv/h, flags=0x${record.flags.toString(16)}`);
            
            // Update current data
            this.currentData.countRate = record.count_rate;
            this.currentData.doseRate = record.dose_rate;
            this.currentData.countRateError = record.count_rate_err;
            this.currentData.doseRateError = record.dose_rate_err;
            
            // Add to smoothie chart
            if (this.countRateTimeSeries && this.doseRateTimeSeries) {
              this.countRateTimeSeries.append(now, record.count_rate);
              // Use original dose rate value (µSv/h) for dose rate chart
              this.doseRateTimeSeries.append(now, record.dose_rate);
            }
            
            // Add to rates series
            this.rates_series[0].data.push([now, record.count_rate]);
            this.rates_series[1].data.push([now, record.dose_rate]);
            
            // Update last update time
            this.deviceInfo.lastUpdate = new Date().toLocaleTimeString();
            
            // Keep only last 100 data points
            if (this.rates_series[0].data.length > 100) {
              this.rates_series[0].data = this.rates_series[0].data.slice(-100);
              this.rates_series[1].data = this.rates_series[1].data.slice(-100);
            }
            
            // Trigger chart update
            this.rates_series = [...this.rates_series];
            break; // Only process the first real-time record
          }
        }
        
      } catch (error) {
        this.log(`❌ Failed to update rates data: ${error.message}`);
      }
    },

    async updateSpectrum() {
      if (!this.isConnected || !this.device) return;
      
      try {
        this.log('Updating spectrum...');
        
        const spectrum = this.spectrum_accum ? 
          await this.device.spectrum_accum() : 
          await this.device.spectrum();
        
        this.spectrum_duration = spectrum.duration;
        this.spectrum_coef = [spectrum.a0, spectrum.a1, spectrum.a2];
        
        // Convert spectrum data to chart format
        const counts = spectrum.counts;
        const data = [];
        
        if (this.spectrum_energy) {
          // Energy scale
          for (let i = 0; i < counts.length; i++) {
            const energy = spectrum.channelToEnergy(i + 0.5);
            data.push([energy, counts[i]]);
          }
        } else {
          // Channel scale
          for (let i = 0; i < counts.length; i++) {
            data.push([i, counts[i]]);
          }
        }
        
        this.spectrum_series = [{
          name: 'Counts',
          data: data
        }];
        
        this.log(`✅ Spectrum updated: ${spectrum.duration}s, ${spectrum.getTotalCounts()} total counts`);
        
      } catch (error) {
        this.log(`❌ Failed to update spectrum: ${error.message}`);
      }
    },

    async resetSpectrum() {
      if (!this.isConnected || !this.device) return;
      
      try {
        this.log('Resetting spectrum...');
        await this.device.spectrum_reset();
        this.log('✅ Spectrum reset successfully');
        
        // Wait a moment then update
        setTimeout(() => {
          this.updateSpectrum();
        }, 1000);
        
      } catch (error) {
        this.log(`❌ Failed to reset spectrum: ${error.message}`);
      }
    },

    clearRatesData() {
      this.rates_series[0].data = [];
      this.rates_series[1].data = [];
      this.rates_series = [...this.rates_series];
      this.log('Rates data cleared');
    }
  },
});
</script>
</body>
</html>
